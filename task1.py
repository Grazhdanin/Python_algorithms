"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

# Python 3.9
# Windows 10 x64

from memory_profiler import profile
import numpy as np

@profile
def asd():
    list_ = list(range(10**5))
    list_ = []
    return True
asd()

'''проверим, что коллекция array из модуля numpy
использует меньше памяти'''
@profile
def np1():
    list_ = list(range(10**5))
    list_1 = np.arange(10**5)
    list_ = []
    return list_1
# действительно, хранение большого списка как <class 'numpy.ndarray'> по памяти выгодно
np1()

# Задача на проверку четности элементов из большого массива натуральных чисел

@profile
def even1():
    result = []
    raw_list = list(range(10**5))
    for el in raw_list:
        if el % 2 == 0 :
            result.append(el)
    return result

even1()

# Используем генератор
@profile
def even2():
    raw_list = list(range(10**5))
    return [el for el in raw_list if el %2 ==0]

even2()

# Использоваине генераторной функции не дало выиграша по памяти

def yield_():
    for el in range(10**5):
        yield el

@profile
def even3():
    a = [el for el in yield_() if el %2 ==0]
    return a


even3()

# Использоваине конструкции  yield дало значиельный выигрыш по памяти